<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<p><b>Apertium New Language Pair HOWTO</b>
</p><p>This HOWTO document will describe how to start a new language pair for the Apertium machine translation system from scratch. You can check the <a href="/wiki/List_of_language_pairs" title="List of language pairs">list of language pairs</a> that have already been started.
</p><p>It does not assume any knowledge of linguistics, or machine translation above the level of being able to distinguish nouns from verbs (and prepositions etc.)
</p>
<h2><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Apertium is, as you've probably realised by now, a machine translation system. Well, not quite, it's a machine translation platform. It provides an engine and toolbox that allow you to build your own machine translation systems. The only thing you need to do is write the data. The data consists, on a basic level, of three dictionaries and a few rules (to deal with word re-ordering and other grammatical stuff).
</p><p>For a more detailed introduction into how it all works, there are some excellent papers on the <a href="/wiki/Publications" title="Publications">Publications</a> page.
</p>
<h2><span class="mw-headline" id="You_will_need">You will need</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=2" title="Edit section: You will need">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>to install Apertium core, usually <a href="/wiki/Install_Apertium_core_using_packaging" title="Install Apertium core using packaging">Install Apertium core using packaging</a></li>
<li>install a new, empty, language pair <a href="/wiki/How_to_bootstrap_a_new_pair" title="How to bootstrap a new pair">How to bootstrap a new pair</a></li>
<li>a text editor (or a specalised <a href="/wiki/XML_editors" title="XML editors">XML editor</a> if you prefer)</li></ul>
<p>This document will not describe how to install these packages, nor the new language framework. For general information please see also <a href="/wiki/Installation" title="Installation">Installation</a>.
</p>
<h2><span id="What_does_a_language_pair_consist_of?"></span><span class="mw-headline" id="What_does_a_language_pair_consist_of.3F">What does a language pair consist of?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=3" title="Edit section: What does a language pair consist of?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Apertium is a shallow-transfer type machine translation system. Thus, it basically works on dictionaries and shallow transfer rules. In operation, shallow-transfer is distinguished from deep-transfer in that it doesn't do full syntactic parsing, the rules are typically operations on groups of lexical units, rather than operations on parse trees. 
</p><p>At a basic level, there are three main dictionaries:
</p>
<ol><li>The <a href="/wiki/Morphological_dictionary" title="Morphological dictionary">morphological dictionary</a> for language xxx: this contains the rules of how words in language xxx are inflected. In our example this will be called: <code>apertium-hbs.hbs.dix</code></li>
<li>The morphological dictionary for language yyy: this contains the rules of how words in language yyy are inflected. In our example this will be called: <code>apertium-eng.eng.dix</code></li>
<li><a href="/wiki/Bilingual_dictionary" title="Bilingual dictionary">Bilingual dictionary</a>: contains correspondences between words and symbols in the two languages. In our example this will be called: <code>apertium-hbs-eng.hbs-eng.dix</code></li></ol>
<p>In a translation pair, both languages can be either source or target for translation; these are relative terms.
</p><p>There are also files for transfer rules in either direction. These are the rules that govern how words are re-ordered in sentences, e.g. <i>chat noir</i> → <i>cat black</i> → <i>black cat</i>. It also governs agreement of gender, number, etc. The rules can also be used to insert or delete lexical items, as will be described later. These files are:
</p>
<ul><li>language xxx to language yyy transfer rules: this file contains rules for how language xxx will be changed into language yyy. In our example this will be: <code>apertium-hbs-eng.hbs-eng.t1x</code></li>
<li>language yyy to xxx language transfer rules: this file contains rules for how language yyy will be changed into language xxx. In our example this will be: <code>apertium-hbs-eng.eng-hbs.t1x</code></li></ul>
<p>Many of the language pairs currently available have other files, but we won't cover them here. If you want to know more about the other files, or the overall process, see <a href="/wiki/Documentation" title="Documentation">Documentation</a>, especially the <a href="/wiki/Workflow_diagram" title="Workflow diagram">Workflow diagram</a>
and <a href="/wiki/Workflow_reference" title="Workflow reference">Workflow reference</a>. But the '.dix' and '.t1x'/'.t2x' files are the only ones required to generate a functional system.
</p>
<h2><span class="mw-headline" id="Language_pair">Language pair</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=4" title="Edit section: Language pair">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>As you may have been alluded to by the file names, this HOWTO will use the example of translating Serbo-Croatian to English to explain how to create a basic system. This is not an ideal pair, since the system works better for more closely related languages. This shouldn't present a problem for the simple examples given here.
</p>
<h2><span class="mw-headline" id="A_brief_note_on_terms">A brief note on terms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=5" title="Edit section: A brief note on terms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are number of terms that will need to be understood before we continue.
</p><p>The first is <i><a href="/wiki/Lemma" title="Lemma">lemma</a></i>. A lemma is the citation form of a word. It is the word stripped of any grammatical information. For example, the lemma of the word cats is <i>cat</i>. In English nouns, this will typically be the singular form of the word in question. For verbs, the lemma is the infinitive stripped of to, e.g., the lemma of <i>was</i> would be <i>be</i>.
</p><p>The second is <i>symbol</i>. In the context of the Apertium system, symbol refers to a grammatical label. The word cats is a plural noun, therefore it will have the noun symbol and the plural symbol. In the input and output of Apertium modules these are typically given between angle brackets, as follows:
</p>
<ul><li><code>&lt;n&gt;</code>; for noun.</li>
<li><code>&lt;pl&gt;</code>; for plural.</li></ul>
<p>Other examples of symbols are &lt;sg&gt;; singular, &lt;p1&gt; first person, &lt;pri&gt; present indicative, etc (see also: <a href="/wiki/List_of_symbols" title="List of symbols">list of symbols</a>). When written in angle brackets, the symbols may also be referred to as tags. It is worth noting that in many of the currently <a href="/wiki/List_of_language_pairs" title="List of language pairs">available language pairs</a> the symbol definitions are acronyms or contractions of words in Catalan. For example, vbhaver — from vb (verb) and haver ("to have" in Catalan). Symbols are defined in &lt;sdef&gt; tags and used in &lt;s&gt; tags.
</p><p>The third word is <i>paradigm</i>. In the context of the Apertium system, paradigm refers to an example of how a particular group of words inflects. In the morphological dictionary, lemmas (see above) are linked to paradigms that allow us to describe how a given lemma inflects without having to write out all of the endings.
</p><p>An example of the utility of this is, if we wanted to store the two adjectives <i>happy</i> and <i>lazy</i>, instead of storing two lots of the same thing:
</p>
<ul><li>happy, happ (y, ier, iest)</li>
<li>lazy, laz (y, ier, iest)</li></ul>
<p>We can simply store one, and then say "lazy, inflects like happy", or indeed "shy inflects like happy", "naughty inflects like happy", "friendly inflects like happy", etc. In this example, happy would be the paradigm, the model for how the others inflect. The precise description of how this is defined will be explained shortly. Paradigms are defined in &lt;pardef&gt; tags, and used in &lt;par&gt; tags.
</p>
<h2><span class="mw-headline" id="Getting_started">Getting started</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=6" title="Edit section: Getting started">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Monolingual_dictionaries">Monolingual dictionaries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=7" title="Edit section: Monolingual dictionaries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<dl><dd><span class="boilerplate seealso"><i>See also: <a href="/wiki/Morphological_dictionary" title="Morphological dictionary">Morphological dictionary</a>, <a href="/wiki/List_of_dictionaries" title="List of dictionaries">List of dictionaries</a>,&#160;and <a href="/wiki/Incubator" title="Incubator">Incubator</a></i></span></dd></dl>
<p>Let's start by making our first source language dictionary, Serbo-Croatian in our example. As mentioned above, this file will be called <code>apertium-hbs.hbs.dix</code>. The dictionary is an XML file. Fire up your text editor and type the following:
</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dictionary&gt;

&lt;/dictionary&gt;
</pre>
<p>So, the file so far defines that we want to start a dictionary. In order for it to be useful, we need to add some more entries, the first is an alphabet. This defines the set of letters that may be used in the dictionary, for Serbo-Croatian. It will look something like the following, containing all the letters of the Serbo-Croatian alphabet:
</p>
<pre>&lt;alphabet&gt;ABCČĆDDžĐEFGHIJKLLjMNNjOPRSŠTUVZŽabcčćddžđefghijklljmnnjoprsštuvzž&lt;/alphabet&gt;
</pre>
<p>Place the alphabet below the &lt;dictionary&gt; tag. (Note: Do not put newlines or space in alphabet!)
</p><p>Next we need to define some symbols. Let's start off with the simple stuff, noun (n) in singular (sg) and plural (pl).
</p>
<pre>&lt;sdefs&gt;
   &lt;sdef n="n"/&gt;
   &lt;sdef n="sg"/&gt;
   &lt;sdef n="pl"/&gt;
&lt;/sdefs&gt;
</pre>
<p>The symbol names do not have to be so small, in fact, they could just be written out in full, but as you'll be typing them a lot, it makes sense to abbreviate.
</p><p>Unfortunately, it isn't quite so simple. Nouns in Serbo-Croatian inflect for more than just number, they are also inflected for case, and have a gender. However, we'll assume for the purposes of this example that the noun is masculine and in the nominative case (a full example may be found at the end of this document).
</p><p>The next thing is to define a section for the paradigms,
</p>
<pre>&lt;pardefs&gt;

&lt;/pardefs&gt;
</pre>
<p>and a dictionary section:
</p>
<pre>&lt;section id="main" type="standard"&gt;

&lt;/section&gt;
</pre>
<p>There are two types of sections, the first is a standard section, that contains words, enclitics, etc. The second type is an <a href="/wiki/Inconditional_section" title="Inconditional section">inconditional section</a> which typically contains punctuation, and so forth. We don't have an inconditional section here.
</p><p>So, our file should now look something like:
</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dictionary&gt;
   &lt;alphabet&gt;ABCČĆDDžĐEFGHIJKLLjMNNjOPRSŠTUVZŽabcčćddžđefghijklljmnnjoprsštuvzž&lt;/alphabet&gt;
   &lt;sdefs&gt;
     &lt;sdef n="n"/&gt;
     &lt;sdef n="sg"/&gt;
     &lt;sdef n="pl"/&gt;
   &lt;/sdefs&gt;
   &lt;pardefs&gt;

   &lt;/pardefs&gt;
   &lt;section id="main" type="standard"&gt;

   &lt;/section&gt;
&lt;/dictionary&gt;
</pre>
<p>Now we've got the skeleton in place, we can start by adding a noun. The noun in question will be 'gramofon' (which means 'gramophone' or 'record player').
</p><p>The first thing we need to do, as we have no prior paradigms, is to define a paradigm inside the &lt;pardefs&gt; tag.
</p><p>Remember, we're assuming masculine gender and nominative case. The singular form of the noun is 'gramofon', and the plural is 'gramofoni'. So:
</p>
<pre>&lt;pardef n="gramofon__n"&gt;
   &lt;e&gt;&lt;p&gt;&lt;l/&gt;&lt;r&gt;&lt;s n="n"/&gt;&lt;s n="sg"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
   &lt;e&gt;&lt;p&gt;&lt;l&gt;i&lt;/l&gt;&lt;r&gt;&lt;s n="n"/&gt;&lt;s n="pl"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
&lt;/pardef&gt;
</pre>
<p>Note: the '&lt;l/&gt;' (equivalent to &lt;l&gt;&lt;/l&gt;) denotes that there is no extra material to be added to the stem for the singular.
</p><p>
This may seem like a rather verbose way of describing it, but there are reasons for this and it quickly becomes second nature. You're probably wondering what the &lt;e&gt;, </p><p>, &lt;l&gt; and &lt;r&gt; stand for. Well,

</p><ul><li>e, is for entry.</li>
<li>p, is for pair.</li>
<li>l, is for left.</li>
<li>r, is for right.</li></ul><p>

Why left and right? Well, the morphological dictionaries will later be compiled into finite state machines. Compiling them left to right produces analyses from words, and from right to left produces words from analyses. For example:
</p><pre>* gramofoni (left to right) gramofon&lt;n&gt;&lt;pl&gt; (analysis)
* gramofon&lt;n&gt;&lt;pl&gt; (right to left) gramofoni (generation)
</pre>
<p>Now we've defined a paradigm, we need to link it to its lemma, gramofon. We put this in the section that we've defined.
</p><p>The entry to put in the &lt;section&gt; will look like:
</p>
<pre>&lt;e lm="gramofon"&gt;&lt;i&gt;gramofon&lt;/i&gt;&lt;par n="gramofon__n"/&gt;&lt;/e&gt;
</pre>
<p>A quick run down on the abbreviations:
</p>
<ul><li>lm, is for lemma.</li>
<li>i, is for identity (the left and the right are the same).</li>
<li>par, is for paradigm.</li></ul>
<p>This entry states the lemma of the word, gramofon, the root, gramofon and the paradigm with which it inflects gramofon__n. The difference between the lemma and the root is that the lemma is the citation form of the word, while the root is the substring of the lemma to which suffixes are added. This will become clearer later when we show an entry where the two are different.
</p><p>We're now ready to test the dictionary. Save it under <code>apertium-hbs.hbs.dix</code>, and then return to the shell. We first need to compile it (with lt-comp), then we can test it (with lt-proc). For those who are new to cygwin just take note that you need to save the dictionary file inside the home folder (for example C:\Apertium\home\Username\filename_of_dictionary). Otherwise you will not be able to compile.
</p>
<pre>$ lt-comp lr apertium-hbs.hbs.dix hbs-eng.automorf.bin
</pre>
<p>Should produce the output:
</p>
<pre>main@standard 12 12
</pre>
<p>As we are compiling it left to right, we're producing an analyser. Lets make a generator too.
</p>
<pre>$ lt-comp rl apertium-hbs.hbs.dix eng-hbs.autogen.bin
</pre>
<p>At this stage, the command should produce the same output.
</p><p>We can now test these. Run lt-proc on the analyser.
</p>
<pre>$ lt-proc hbs-eng.automorf.bin
</pre>
<p>Now try it out, type in "gramofoni" (gramophones), and see the output:
</p>
<pre>^gramofoni/gramofon&lt;n&gt;&lt;pl&gt;$
</pre>
<p>Now, for the English dictionary, do the same thing, but substitute the English word gramophone for gramofon, and change the plural inflection. What if you want to use the more correct word 'record player'? Well, we'll explain how to do that later.
</p><p>You should now have two files:
</p>
<ul><li>apertium-hbs.hbs.dix which contains a (very) basic Serbo-Croatian morphological dictionary, and</li>
<li>apertium-eng.eng.dix which contains a (very) basic English morphological dictionary.</li></ul>
<h3><span class="mw-headline" id="Bilingual_dictionary">Bilingual dictionary</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=8" title="Edit section: Bilingual dictionary">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><i>See also: <a href="/wiki/Bilingual_dictionary" title="Bilingual dictionary">Bilingual dictionary</a></i>
</p><p>So we now have two morphological dictionaries, next thing to make is the <a href="/wiki/Bilingual_dictionary" title="Bilingual dictionary">bilingual dictionary</a>. This describes mappings between words. All dictionaries use the same format (which is specified in the DTD, dix.dtd).
</p><p>Create a new file, <code>apertium-hbs-eng.hbs-eng.dix</code> and add the basic skeleton:
</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dictionary&gt;
   &lt;alphabet/&gt;
   &lt;sdefs&gt;
     &lt;sdef n="n"/&gt;
     &lt;sdef n="sg"/&gt;
     &lt;sdef n="pl"/&gt;
   &lt;/sdefs&gt;

   &lt;section id="main" type="standard"&gt;

   &lt;/section&gt;
&lt;/dictionary&gt;
</pre>
<p>Now we need to add an entry to translate between the two words. Something like:
</p>
<pre>&lt;e&gt;&lt;p&gt;&lt;l&gt;gramofon&lt;s n="n"/&gt;&lt;/l&gt;&lt;r&gt;gramophone&lt;s n="n"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
</pre>
<p>Because there are a lot of these entries, they're typically written on one line to facilitate easier reading of the file. Again with the 'l' and 'r' right? Well, we compile it left to right to produce the Serbo-Croatian → English dictionary, and right to left to produce the English → Serbo-Croatian dictionary.
</p><p>So, once this is done, run the following commands:
</p>
<pre>$ lt-comp lr apertium-hbs.hbs.dix hbs-eng.automorf.bin
$ lt-comp rl apertium-eng.eng.dix hbs-eng.autogen.bin

$ lt-comp lr apertium-eng.eng.dix eng-hbs.automorf.bin
$ lt-comp rl apertium-hbs.hbs.dix eng-hbs.autogen.bin

$ lt-comp lr apertium-hbs-eng.hbs-eng.dix hbs-eng.autobil.bin
$ lt-comp rl apertium-hbs-eng.hbs-eng.dix eng-hbs.autobil.bin
</pre>
<p>To generate the morphological analysers (automorf), the morphological generators (autogen) and the word lookups (autobil), the bil is for "bilingual".
</p>
<h3><span class="mw-headline" id="Transfer_rules">Transfer rules</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=9" title="Edit section: Transfer rules">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>So, now we have two morphological dictionaries, and a bilingual dictionary. All that we need now is a transfer rule for nouns. Transfer rule files have their own DTD (transfer.dtd) which can be found in the Apertium package. If you need to implement a rule it is often a good idea to look in the rule files of other language pairs first. Many rules can be recycled/reused between languages. For example the one described below would be useful for any null-subject language.
</p><p>Start out like all the others with a basic skeleton (<code>apertium-hbs-eng.hbs-eng.t1x</code>)&#160;:
</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;transfer&gt;

&lt;/transfer&gt;
</pre>
<p>At the moment, because we're ignoring case, we just need to make a rule that takes the grammatical symbols input and outputs them again.
</p><p>We first need to define categories and attributes. Categories and attributes both allow us to group grammatical symbols. Categories allow us to group symbols for the purposes of matching (for example 'n.*' is all nouns). Attributes allow us to group a set of symbols that can be chosen from. For example ('sg' and 'pl' may be grouped a an attribute 'number').
</p><p>Lets add the necessary sections:
</p>
<pre>&lt;section-def-cats&gt;

&lt;/section-def-cats&gt;
&lt;section-def-attrs&gt;

&lt;/section-def-attrs&gt;
</pre>
<p>As we're only inflecting, nouns in singular and plural then we need to add a category for nouns, and with an attribute of number. Something like the following will suffice:
</p><p>Into section-def-cats add:
</p>
<pre>&lt;def-cat n="nom"&gt;
   &lt;cat-item tags="n.*"/&gt;
&lt;/def-cat&gt;
</pre>
<p>This catches all nouns (lemmas followed by &lt;n&gt; then anything) and refers to them as "nom" (we'll see how that's used later).
</p><p>Into the section section-def-attrs, add:
</p>
<pre>&lt;def-attr n="nbr"&gt;
   &lt;attr-item tags="sg"/&gt;
   &lt;attr-item tags="pl"/&gt;
&lt;/def-attr&gt;
</pre>
<p>and then
</p>
<pre>&lt;def-attr n="a_nom"&gt;
   &lt;attr-item tags="n"/&gt;
&lt;/def-attr&gt;
</pre>
<p>The first defines the attribute nbr (number), which can be either singular (sg) or plural (pl).
</p><p>The second defines the attribute a_nom (attribute noun).
</p><p>Next we need to add a section for global variables:
</p>
<pre>&lt;section-def-vars&gt;

&lt;/section-def-vars&gt;
</pre>
<p>These variables are used to store or transfer attributes between rules. We need only one for now so that the file can be validated,
</p>
<pre>&lt;def-var n="number"/&gt;
</pre>
<p>Finally, we need to add a rule, to take in the noun and then output it in the correct form. We'll need a rules section...
</p>
<pre>&lt;section-rules&gt;

&lt;/section-rules&gt;
</pre>
<p>Changing the pace from the previous examples, I'll just paste this rule, then go through it, rather than the other way round.
</p>
<pre>&lt;rule&gt;
   &lt;pattern&gt;
     &lt;pattern-item n="nom"/&gt;
   &lt;/pattern&gt;
   &lt;action&gt;
     &lt;out&gt;
       &lt;lu&gt;
         &lt;clip pos="1" side="tl" part="lem"/&gt;
         &lt;clip pos="1" side="tl" part="a_nom"/&gt;
         &lt;clip pos="1" side="tl" part="nbr"/&gt;
       &lt;/lu&gt;
     &lt;/out&gt;
   &lt;/action&gt;
&lt;/rule&gt;
</pre>
<p>The first tag is obvious, it defines a rule. The second tag, pattern basically says: "apply this rule, if this pattern is found". In this example the pattern consists of a single noun (defined by the category item nom). Note that patterns are matched in a longest-match first. So, say you have three rules, the first catches the pattern: <code>&lt;prn&gt; &lt;vblex&gt; &lt;n&gt;</code>, the second catches <code>&lt;prn&gt; &lt;vblex&gt;</code> and the third catches <code>&lt;n&gt;</code>. The pattern matched, and rule executed would be the first one.
</p><p>For each pattern, there is an associated action, which produces an associated output, out. The output, is a lexical unit (lu).
</p><p>The clip tag allows a user to select and manipulate attributes and parts of the source language (side="sl"), or target language (side="tl") lexical item.
</p><p>Let's compile it and test it. Transfer rules are compiled with:
</p>
<pre>$ apertium-preprocess-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin
</pre>
<p>Which will generate a <code>hbs-eng.t1x.bin</code> file.
</p><p>Now we're ready to test our machine translation system. There is one crucial part missing, the part-of-speech (PoS) tagger, but that will be explained shortly. In the meantime we can test it as is:
</p><p>First, lets analyse a word, gramofoni:
</p>
<pre>$ echo "gramofoni" | lt-proc hbs-eng.automorf.bin 
^gramofoni/gramofon&lt;n&gt;&lt;pl&gt;$
</pre>
<p>Now, normally here the POS tagger would choose the right version based on the part of speech, but we don't have a POS tagger yet, so we can use this little gawk script (thanks to Sergio) that will just output the first item retrieved.
</p>
<pre>$ echo "gramofoni" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}'
^gramofon&lt;n&gt;&lt;pl&gt;$
</pre>
<p>Now let's process that with the transfer rule:
</p>
<pre>$ echo "gramofoni" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin
</pre>
<p>It will output:
</p>
<pre>^gramophone&lt;n&gt;&lt;pl&gt;$^@
</pre>
<ul><li>'gramophone' is the target language (side="tl") lemma (lem) at position 1 (pos="1").</li>
<li>'&lt;n&gt;' is the target language a_nom at position 1.</li>
<li>'&lt;pl&gt;' is the target language attribute of number (nbr) at position 1.</li></ul>
<p>Try commenting out one of these clip statements, recompiling and seeing what happens.
</p><p>So, now we have the output from the transfer, the only thing that remains is to generate the target-language inflected forms. For this, we use lt-proc, but in generation (-g), not analysis mode.
</p>
<pre>$ echo "gramofoni" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin | \
  lt-proc -g hbs-eng.autogen.bin

gramophones\@
</pre>
<p>And c'est ca. You now have a machine translation system that translates a Serbo-Croatian noun into an English noun. Obviously this isn't very useful, but we'll get onto the more complex stuff soon. Oh, and don't worry about the '@' symbol, I'll explain that soon too.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">&#91;1&#93;</a></sup>
</p><p>Think of a few other words that inflect the same as gramofon. How about adding those. We don't need to add any paradigms, just the entries in the main section of the monolingual and bilingual dictionaries.
</p>
<h2><span class="mw-headline" id="Bring_on_the_verbs">Bring on the verbs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=10" title="Edit section: Bring on the verbs">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Ok, so we have a system that translates nouns, but that's pretty useless, we want to translate verbs too, and even whole sentences! How about we start with the verb to see. In Serbo-Croatian this is videti. Serbo-Croatian is a null-subject language, this means that it doesn't typically use personal pronouns before the conjugated form of the verb. English is not. So for example: I see in English would be translated as vidim in Serbo-Croatian.
</p>
<ul><li>Vidim</li>
<li>see&lt;p1&gt;&lt;sg&gt;</li>
<li>I see</li></ul>
<p>Note: <code>&lt;p1&gt;</code> denotes first person
</p><p>This will be important when we come to write the transfer rule for verbs. Other examples of null-subject languages include: Spanish, Romanian and Polish. This also has the effect that while we only need to add the verb in the Serbo-Croatian morphological dictionary, we need to add both the verb, and the personal pronouns in the English morphological dictionary. We'll go through both of these.
</p><p>The other forms of the verb videti are: vidiš, vidi, vidimo, vidite, and vide; which correspond to: you see (singular), he sees, we see, you see (plural), and they see.
</p><p>There are two forms of you see, one is plural and formal singular (vidite) and the other is singular and informal (vidiš).
</p><p>We're going to try and translate the sentence: "Vidim gramofoni" into "I see gramophones". In the interests of space, we'll just add enough information to do the translation and will leave filling out the paradigms (adding the other conjugations of the verb) as an exercise to the reader.
</p><p>The astute reader will have realised by this point that we can't just translate vidim gramofoni because it is not a grammatically correct sentence in Serbo-Croatian. The correct sentence would be vidim gramofone, as the noun takes the accusative case. We'll have to add that form too, no need to add the case information for now though, we just add it as another option for plural. So, in the paradigm definition just copy the 'e' block for 'i' and change the 'i' to 'e' there.
</p>
<pre>&lt;pardef n="gramofon__n"&gt;
   &lt;e&gt;&lt;p&gt;&lt;l/&gt;&lt;r&gt;&lt;s n="n"/&gt;&lt;s n="sg"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
   &lt;e&gt;&lt;p&gt;&lt;l&gt;i&lt;/l&gt;&lt;r&gt;&lt;s n="n"/&gt;&lt;s n="pl"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
   &lt;e&gt;&lt;p&gt;&lt;l&gt;e&lt;/l&gt;&lt;r&gt;&lt;s n="n"/&gt;&lt;s n="pl"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
&lt;/pardef&gt;
</pre>
<p>First thing we need to do is add some more symbols. We need to first add a symbol for 'verb', which we'll call "vblex" (this means lexical verb, as opposed to modal verbs and other types). Verbs have 'person', and 'tense' along with number, so lets add a couple of those as well. We need to translate "I see", so for person we should add "p1", or 'first person', and for tense "pri", or 'present indicative'.
</p>
<pre>&lt;sdef n="vblex"/&gt;
&lt;sdef n="p1"/&gt;
&lt;sdef n="pri"/&gt;
</pre>
<p>After we've done this, the same with the nouns, we add a paradigm for the verb conjugation. The first line will be:
</p>
<pre>&lt;pardef n="vid/eti__vblex"&gt;
</pre>
<p>The '/' is used to demarcate where the stems (the parts between the &lt;l&gt; &lt;/l&gt; tags) are added to.
</p><p>Then the inflection for first person singular:
</p>
<pre>

&lt;e&gt;&lt;p&gt;&lt;l&gt;im&lt;/l&gt;&lt;r&gt;eti&lt;s n="vblex"/&gt;&lt;s n="pri"/&gt;&lt;s n="p1"/&gt;&lt;s n="sg"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;

</pre>
<p>The 'im' denotes the ending (as in 'vidim'), it is necessary to add 'eti' to the &lt;r&gt; section, as this will be chopped off by the definition. The rest is fairly straightforward, 'vblex' is lexical verb, 'pri' is present indicative tense, 'p1' is first person and 'sg' is singular. We can also add the plural which will be the same, except 'imo' instead of 'im' and 'pl' instead of 'sg'.
</p><p>After this we need to add a lemma, paradigm mapping to the main section:
</p>
<pre>&lt;e lm="videti"&gt;&lt;i&gt;vid&lt;/i&gt;&lt;par n="vid/eti__vblex"/&gt;&lt;/e&gt;
</pre>
<p>Note: the content of &lt;i&gt; &lt;/i&gt; is the root, not the lemma.
</p><p>That's the work on the Serbo-Croatian dictionary done for now. Lets compile it then test it.
</p>
<pre>$ lt-comp lr apertium-hbs.hbs.dix hbs-eng.automorf.bin
main@standard 23 25
$ echo "vidim" | lt-proc hbs-eng.automorf.bin
^vidim/videti&lt;vblex&gt;&lt;pri&gt;&lt;p1&gt;&lt;sg&gt;$
$ echo "vidimo" | lt-proc hbs-eng.automorf.bin
^vidimo/videti&lt;vblex&gt;&lt;pri&gt;&lt;p1&gt;&lt;pl&gt;$
</pre>
<p>Ok, so now we do the same for the English dictionary (remember to add the same symbol definitions here as you added to the Serbo-Croatian one).
</p><p>The paradigm is:
</p>
<pre>&lt;pardef n="s/ee__vblex"&gt;
</pre>
<p>because the past tense is 'saw'. Now, we can do one of two things, we can add both first and second person, but they are the same form. In fact, all forms (except third person singular) of the verb 'to see' are 'see'. So instead we make one entry for 'see' and give it only the 'pri' symbol.
</p>
<pre>

&lt;e&gt;&lt;p&gt;&lt;l&gt;ee&lt;/l&gt;&lt;r&gt;ee&lt;s n="vblex"/&gt;&lt;s n="pri"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;

</pre>
<p>and as always, an entry in the main section:
</p>
<pre>&lt;e lm="see"&gt;&lt;i&gt;s&lt;/i&gt;&lt;par n="s/ee__vblex"/&gt;&lt;/e&gt;
</pre>
<p>Then lets save, recompile and test:
</p>
<pre>$ lt-comp lr apertium-eng.eng.dix eng-hbs.automorf.bin
main@standard 18 19

$ echo "see" | lt-proc eng-hbs.automorf.bin
^see/see&lt;vblex&gt;&lt;pri&gt;$
</pre>
<p>Now for the obligatory entry in the bilingual dictionary:
</p>
<pre>&lt;e&gt;&lt;p&gt;&lt;l&gt;videti&lt;s n="vblex"/&gt;&lt;/l&gt;&lt;r&gt;see&lt;s n="vblex"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
</pre>
<p>(again, don't forget to add the sdefs from earlier)
</p><p>And recompile:
</p>
<pre>$ lt-comp lr apertium-hbs-eng.hbs-eng.dix hbs-eng.autobil.bin
main@standard 18 18
$ lt-comp rl apertium-hbs-eng.hbs-eng.dix eng-hbs.autobil.bin
main@standard 18 18
</pre>
<p>Now to test:
</p>
<pre>$ echo "vidim" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin

^see&lt;vblex&gt;&lt;pri&gt;&lt;p1&gt;&lt;sg&gt;$^@
</pre>
<p>We get the analysis passed through correctly, but when we try and generate a surface form from this, we get a '#', like below:
</p>
<pre>$ echo "vidim" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin | \
  lt-proc -g hbs-eng.autogen.bin
#see\@
</pre>
<p>This '#' means that the generator cannot generate the correct lexical form because it does not contain it. Why is this?
</p><p>Basically the analyses don't match, the 'see' in the dictionary is see&lt;vblex&gt;&lt;pri&gt;, but the see delivered by the transfer is see&lt;vblex&gt;&lt;pri&gt;&lt;p1&gt;&lt;sg&gt;. The Serbo-Croatian side has more information than the English side requires. You can test this by adding the missing symbols to the English dictionary, and then recompiling, and testing again.
</p><p>However, a more paradigmatic way of taking care of this is by writing a rule. So, we open up the rules file (<code>apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin</code> in case you forgot).
</p><p>We need to add a new category for 'verb'.
</p>
<pre>&lt;def-cat n="vrb"&gt;
   &lt;cat-item tags="vblex.*"/&gt;
&lt;/def-cat&gt;
</pre>
<p>We also need to add attributes for tense and for person. We'll make it really simple for now, you can add p2 and p3, but I won't in order to save space.
</p>
<pre>&lt;def-attr n="temps"&gt;
   &lt;attr-item tags="pri"/&gt;
&lt;/def-attr&gt;

&lt;def-attr n="pers"&gt;
   &lt;attr-item tags="p1"/&gt;
&lt;/def-attr&gt;
</pre>
<p>We should also add an attribute for verbs.
</p>
<pre>&lt;def-attr n="a_verb"&gt;
   &lt;attr-item tags="vblex"/&gt;
&lt;/def-attr&gt;
</pre>
<p>Now onto the rule:
</p>
<pre>&lt;rule&gt;
   &lt;pattern&gt;
     &lt;pattern-item n="vrb"/&gt;
   &lt;/pattern&gt;
   &lt;action&gt;
     &lt;out&gt;
       &lt;lu&gt;
         &lt;clip pos="1" side="tl" part="lem"/&gt;
         &lt;clip pos="1" side="tl" part="a_verb"/&gt;
         &lt;clip pos="1" side="tl" part="temps"/&gt;
       &lt;/lu&gt;
     &lt;/out&gt;
   &lt;/action&gt;
&lt;/rule&gt;
</pre>
<p>Remember when you tried commenting out the 'clip' tags in the previous rule example and they disappeared from the transfer, well, that's pretty much what we're doing here. We take in a verb with a full analysis, but only output a partial analysis (lemma + verb tag + tense tag).
</p><p>So now, if we recompile that, we get:
</p>
<pre>$ echo "vidim" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin
^see&lt;vblex&gt;&lt;pri&gt;$^@
</pre>
<p>and:
</p>
<pre>$ echo "vidim" | lt-proc hbs-eng.automorf.bin  | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin | \
  lt-proc -g hbs-eng.autogen.bin
see\@
</pre>
<p>Try it with 'vidimo' (we see) to see if you get the correct output.
</p><p>Now try it with "vidim gramofone":
</p>
<pre>$ echo "vidim gramofoni" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin | \
  lt-proc -g hbs-eng.autogen.bin
see gramophones\@
</pre>
<h2><span id="But_what_about_personal_pronouns?"></span><span class="mw-headline" id="But_what_about_personal_pronouns.3F">But what about personal pronouns?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=11" title="Edit section: But what about personal pronouns?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Well, that's great, but we're still missing the personal pronoun that is necessary in English. In order to add it in, we first need to edit the English morphological dictionary.
</p><p>As before, the first thing to do is add the necessary symbols:
</p>
<pre>&lt;sdef n="prn"/&gt;
&lt;sdef n="subj"/&gt;
</pre>
<p>Of the two symbols, prn is pronoun, and subj is subject (as in the subject of a sentence).
</p><p>Because there is no root, or 'lemma' for personal subject pronouns, we just add the pardef as follows:
</p>
<pre>&lt;pardef n="prsubj__prn"&gt;
   &lt;e&gt;&lt;p&gt;&lt;l&gt;I&lt;/l&gt;&lt;r&gt;prpers&lt;s n="prn"/&gt;&lt;s n="subj"/&gt;&lt;s n="p1"/&gt;&lt;s n="sg"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;
&lt;/pardef&gt;
</pre>
<p>With 'prsubj' being 'personal subject'. The rest of them (You, We etc.) are left as an exercise to the reader.
</p><p>We can add an entry to the main section as follows:
</p>
<pre>&lt;e lm="personal subject pronouns"&gt;&lt;i/&gt;&lt;par n="prsubj__prn"/&gt;&lt;/e&gt;
</pre>
<p>So, save, recompile and test, and we should get something like:
</p>
<pre>$ echo "I" | lt-proc eng-hbs.automorf.bin
^I/PRPERS&lt;prn&gt;&lt;subj&gt;&lt;p1&gt;&lt;sg&gt;$
</pre>
<p>(Note: it's in capitals because 'I' is in capitals).
</p><p>Now we need to amend the 'verb' rule to output the subject personal pronoun along with the correct verb form.
</p><p>First, add a category (this must be getting pretty pedestrian by now):
</p>
<pre>&lt;def-cat n="prpers"&gt;
   &lt;cat-item lemma="prpers" tags="prn.*"/&gt;
&lt;/def-cat&gt;
</pre>
<p>Now add the types of pronoun as attributes, we might as well add the 'obj' type as we're at it, although we won't need to use it for now:
</p>
<pre>&lt;def-attr n="tipus_prn"&gt;
   &lt;attr-item tags="prn.subj"/&gt;
   &lt;attr-item tags="prn.obj"/&gt;
&lt;/def-attr&gt;
</pre>
<p>And now to input the rule:
</p>
<pre>&lt;rule&gt;
   &lt;pattern&gt;
     &lt;pattern-item n="vrb"/&gt;
   &lt;/pattern&gt;
   &lt;action&gt;
     &lt;out&gt;
       &lt;lu&gt;
         &lt;lit v="prpers"/&gt;
         &lt;lit-tag v="prn"/&gt;
         &lt;lit-tag v="subj"/&gt;
         &lt;clip pos="1" side="tl" part="pers"/&gt;
         &lt;clip pos="1" side="tl" part="nbr"/&gt;
       &lt;/lu&gt;
       &lt;b/&gt;
       &lt;lu&gt;
         &lt;clip pos="1" side="tl" part="lem"/&gt;
         &lt;clip pos="1" side="tl" part="a_verb"/&gt;
         &lt;clip pos="1" side="tl" part="temps"/&gt;
       &lt;/lu&gt;
     &lt;/out&gt;
   &lt;/action&gt;
&lt;/rule&gt;
</pre>
<p>This is pretty much the same rule as before, only we made a couple of small changes.
</p><p>We needed to output:
</p>
<pre>^prpers&lt;prn&gt;&lt;subj&gt;&lt;p1&gt;&lt;sg&gt;$ ^see&lt;vblex&gt;&lt;pri&gt;$
</pre>
<p>so that the generator could choose the right pronoun and the right form of the verb.
</p><p>So, a quick rundown:
</p>
<ul><li><code>&lt;lit&gt;</code>, prints a literal string, in this case "prpers"</li>
<li><code>&lt;lit-tag&gt;</code>, prints a literal tag, because we can't get the tags from the verb, we add these ourself, "prn" for pronoun, and "subj" for subject.</li>
<li><code><b></b></code>, prints a blank, a space.</li></ul>
<p>Note that we retrieved the information for number and tense directly from the verb.
</p><p>So, now if we recompile and test that again:
</p>
<pre>$ echo "vidim gramofone" | lt-proc hbs-eng.automorf.bin  | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin | \
  lt-proc -g hbs-eng.autogen.bin
I see gramophones
</pre>
<p>Which, while it isn't exactly prize-winning prose (much like this HOWTO), is a fairly accurate translation.
</p>
<h2><span id="So_tell_me_about_the_record_player_(Multiwords)"></span><span class="mw-headline" id="So_tell_me_about_the_record_player_.28Multiwords.29">So tell me about the record player (Multiwords)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=12" title="Edit section: So tell me about the record player (Multiwords)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>While gramophone is an English word, it isn't the best translation. Gramophone is typically used for the very old kind, you know with the needle instead of the stylus, and no powered amplification. A better translation would be 'record player'. Although this is more than one word, we can treat it as if it is one word by using multiword (multipalabra) constructions.
</p><p>We don't need to touch the Serbo-Croatian dictionary, just the English one and the bilingual one, so open it up.
</p><p>The plural of 'record player' is 'record players', so it takes the same paradigm as gramophone (gramophone__n) — in that we just add 's'. All we need to do is add a new element to the main section.
</p>
<pre>&lt;e lm="record player"&gt;&lt;i&gt;record&lt;b/&gt;player&lt;/i&gt;&lt;par n="gramophone__n"/&gt;&lt;/e&gt;
</pre>
<p>The only thing different about this is the use of the <b></b> tag, although this isn't entirely new as we saw it in use in the rules file.
</p><p>So, recompile and test in the orthodox fashion:
</p>
<pre>$ echo "vidim gramofone" | lt-proc hbs-eng.automorf.bin | \
  gawk 'BEGIN{RS="$"; FS="/";}{nf=split($1,COMPONENTS,"^"); for(i = 1; i&lt;nf; i++) printf COMPONENTS[i]; if($2&#160;!= "") printf("^%s$",$2);}' | \
  apertium-transfer apertium-hbs-eng.hbs-eng.t1x hbs-eng.t1x.bin hbs-eng.autobil.bin  | \
  lt-proc -g hbs-eng.autogen.bin
I see record players
</pre>
<p>Perfect. A big benefit of using multiwords is that you can translate idiomatic expressions verbatim, without having to do word-by-word translation. For example the English phrase, "at the moment" would be translated into Serbo-Croatian as "trenutno" (trenutak = <i>moment</i>, trenutno being adverb of that) &#8212; it would not be possible to translate this English phrase word-by-word into Serbo-Croatian.
</p>
<h2><span class="mw-headline" id="Dealing_with_minor_variation">Dealing with minor variation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=13" title="Edit section: Dealing with minor variation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Serbo-Croatian is an umbrella term for several standard languages, so there are differences in pronounciation and ortography. There is a cool phonetic writing system so you write how you speak. A notable example is the pronounciation of the proto-Slavic vowel <i>yat</i>. The word for dictionary can for instance be either "rječnik" (called Ijekavian), or "rečnik" (called Ekavian).
</p>
<h3><span class="mw-headline" id="Analysis">Analysis</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=14" title="Edit section: Analysis">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>There should be a fairly easy way of dealing with this, and there is, using paradigms again. Paradigms aren't only used for adding grammatical symbols, but they can also be used to replace any character/symbol with another. For example, here is a paradigm for accepting both "e" and "je" in the analysis. The paradigm should, as with the others go into the monolingual dictionary for Serbo-Croatian.
</p>
<pre>  &lt;pardef n="e_je__yat"&gt;
    &lt;e&gt;
      &lt;p&gt;
        &lt;l&gt;e&lt;/l&gt;
        &lt;r&gt;e&lt;/r&gt;
      &lt;/p&gt;
    &lt;/e&gt;
    &lt;e&gt;
      &lt;p&gt;
        &lt;l&gt;je&lt;/l&gt;
        &lt;r&gt;e&lt;/r&gt;
      &lt;/p&gt;
    &lt;/e&gt;
  &lt;/pardef&gt;
</pre>
<p>Then in the "main section":
</p>
<pre>    &lt;e lm="rečnik"&gt;&lt;i&gt;r&lt;/i&gt;&lt;par n="e_je__yat"/&gt;&lt;i&gt;čni&lt;/i&gt;&lt;par n="rečni/k__n"/&gt;&lt;/e&gt;
</pre>
<p>This only allows us to analyse both forms however... more work is necessary if we want to generate both forms.
</p>
<h3><span class="mw-headline" id="Generation">Generation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=15" title="Edit section: Generation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=16" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1">↑</a></span> <span class="reference-text">Turns out I didn't get around to explaining it, so: The <code>@</code> symbol appears because of the full stop '<code>.</code>' that is added to every translation in case it doesn't have one. For the technically minded, this is so that the tagger knows when a new sentence is starting, even if there isn't a full stop there.</span>
</li>
</ol></div>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Apertium_New_Language_Pair_HOWTO&amp;action=edit&amp;section=17" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li><a href="/wiki/Building_dictionaries" title="Building dictionaries">Building dictionaries</a></li>
<li><a href="/wiki/Finding_errors_in_dictionaries" title="Finding errors in dictionaries">Finding errors in dictionaries</a></li>
<li><a href="/w/index.php?title=Cookbook&amp;action=edit&amp;redlink=1" class="new" title="Cookbook (page does not exist)">Cookbook</a></li>
<li><a href="/wiki/Chunking" title="Chunking">Chunking</a></li>
<li><a href="/wiki/Contributing_to_an_existing_pair" title="Contributing to an existing pair">Contributing to an existing pair</a></li></ul>

</html>
